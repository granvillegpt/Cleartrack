<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin Dashboard - ClearTrack</title>
  <link rel="icon" type="image/png" href="assets/images/icon%20logo.png">
  
  <!-- PWA Features - Only on app.cleartrack.co.za -->
  <script>
    if (window.location.hostname === 'app.cleartrack.co.za') {
      document.write('<link rel="manifest" href="/manifest.json">');
      document.write('<meta name="theme-color" content="#0b7285">');
      document.write('<link rel="apple-touch-icon" sizes="192x192" href="/icons/cleartrack-192.png">');
      document.write('<link rel="apple-touch-icon" sizes="512x512" href="/icons/cleartrack-512.png">');
      document.write('<meta name="apple-mobile-web-app-capable" content="yes">');
      document.write('<meta name="mobile-web-app-capable" content="yes">');
      document.write('<meta name="apple-mobile-web-app-status-bar-style" content="default">');
    }
  </script>
  <link rel="stylesheet" href="global-styles.css">
  <link rel="stylesheet" href="whatsapp-messaging.css">
  <link rel="stylesheet" href="responsive-fixes.css">
  <link rel="stylesheet" href="css/ct-theme.css" />
  <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #e5f3f7;
            color: #333;
        }
        
        /* ============================================
           HEADER CONTAINER
           ============================================ */
        .header {
            background: #0b7285;
            color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            width: 100%;
            box-sizing: border-box;
            display: block;
            visibility: visible;
            opacity: 1;
        }
        
        /* ============================================
           HEADER TOP SECTION
           ============================================ */
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2.5rem;
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Logout Button - Desktop positioning */
        #desktopLogoutBtn {
            display: block;
            margin-left: auto;
        }
        
        /* ============================================
           LOGO
           ============================================ */
        .header .logo {
            display: flex;
            align-items: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .header .logo img {
            height: 48px;
            width: auto;
            filter: brightness(0) invert(1);
            display: block;
        }
        
        /* ============================================
           NAVIGATION
           ============================================ */
        .nav {
            display: flex;
            gap: 2rem;
            align-items: center;
            justify-content: center;
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            width: 100%;
            box-sizing: border-box;
        }
        
        .nav a {
            text-decoration: none;
            color: #e0fbff;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s;
            position: relative;
        }
        
        .nav a::after {
            content: '';
            position: absolute;
            bottom: -0.5rem;
            left: 0;
            width: 0;
            height: 2px;
            background: #ffffff;
            transition: width 0.3s ease;
        }
        
        .nav a:hover::after,
        .nav a.active::after {
            width: 100%;
        }
        
        .nav a:hover,
        .nav a.active {
            color: #ffffff;
        }
        
        /* Admin Dashboard Title */
        .nav-title {
            color: #ffffff;
            font-weight: 600;
            font-size: 1rem;
            letter-spacing: 0.5px;
        }
        
        /* ============================================
           USER MENU
           ============================================ */
        .user-menu {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        /* ============================================
           MOBILE MENU TOGGLE
           ============================================ */
        .menu-toggle-style6 {
            display: none;
            background: transparent;
            border: none;
            color: #e0fbff;
            cursor: pointer;
            font-size: 1.3rem;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            transition: transform 0.3s ease;
            padding: 0;
        }
        
        .menu-toggle-style6:hover {
            transform: scale(1.1);
        }
        
        .menu-toggle-style6.active {
            transform: rotate(90deg);
        }
        
        /* ============================================
           MOBILE NAVIGATION (nav-style6)
           ============================================ */
        .nav-style6 {
            display: flex;
            gap: 2rem;
            align-items: center;
            justify-content: center;
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            width: 100%;
            box-sizing: border-box;
        }
        
        /* ============================================
           DESKTOP STYLES (min-width: 769px)
           ============================================ */
        @media (min-width: 769px) {
            /* Hide mobile menu toggle on desktop */
            .menu-toggle-style6 {
                display: none;
                visibility: hidden;
                opacity: 0;
                pointer-events: none;
            }
            
            /* Desktop navigation */
            .nav-style6 {
                display: flex;
                position: static;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 0;
                box-shadow: none;
                flex-direction: row;
            }
            
            .nav-style6 a {
                color: #e0fbff;
                padding: 0.5rem 0;
                width: auto;
                display: inline-block;
            }
        }
        
        /* ============================================
           MOBILE STYLES (max-width: 768px)
           ============================================ */
        @media (max-width: 768px) {
            /* Header container */
            .header {
                display: block;
                padding: 0;
                width: 100%;
                max-width: 100vw;
                position: relative;
            }
            
            /* Header top - reduced padding for mobile */
            .header-top {
                padding: 0.875rem 1rem;
                width: 100%;
                max-width: 100vw;
                box-sizing: border-box;
                min-height: 56px;
            }
            
            /* Show mobile menu toggle */
            .header .menu-toggle-style6 {
                display: flex;
                flex-shrink: 0;
                width: 36px;
                height: 36px;
                min-width: 36px;
                min-height: 36px;
                order: 1;
                z-index: 2;
                position: relative;
                left: auto;
                background: transparent;
                color: #e0fbff;
            }
            
            /* Mobile dropdown navigation */
            .nav-style6 {
                display: none;
                position: absolute;
                top: calc(100% + 0.5rem);
                right: 1rem;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.2);
                min-width: 220px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease, opacity 0.3s ease;
                opacity: 0;
                z-index: 1000;
                flex-direction: column;
                align-items: stretch;
                gap: 0;
                padding: 0;
                margin: 0;
                border-top: none;
            }
            
            .nav-style6.active {
                display: flex;
                max-height: 400px;
                opacity: 1;
            }
            
            .nav-style6 a {
                width: 100%;
                color: #1f2933;
                padding: 0.75rem 1.25rem;
                font-size: 0.95rem;
                display: block;
                transition: all 0.2s;
                text-decoration: none;
                border-bottom: none;
            }
            
            .nav-style6 a:hover {
                background: #f5f7fa;
                color: #0b7285;
                padding-left: 1.5rem;
            }
            
            .nav-style6 a:first-child {
                border-radius: 12px 12px 0 0;
            }
            
            .nav-style6 a:last-child {
                border-radius: 0 0 12px 12px;
            }
            
            /* Center logo on mobile */
            .header .logo {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
                width: auto;
                max-width: 140px;
                z-index: 1;
                pointer-events: auto;
            }
            
            .header .logo img {
                height: 32px;
                max-width: 120px;
                width: auto;
                object-fit: contain;
                display: block;
            }
            
            /* Hide desktop navigation */
            .nav {
                display: none;
            }
            
            /* Hide desktop logout button on mobile (handled by JavaScript) */
            #desktopLogoutBtn {
                display: none;
            }
        }
        
        /* ============================================
           SMALL MOBILE STYLES (max-width: 480px)
           ============================================ */
        @media (max-width: 480px) {
            /* Header top - same padding as 768px breakpoint */
            .header-top {
                padding: 0.875rem 1rem;
            }
            
            /* Mobile menu toggle */
            .header .menu-toggle-style6 {
                display: flex;
                width: 36px;
                height: 36px;
                min-width: 36px;
                min-height: 36px;
                color: #e0fbff;
            }
            
            /* Adjust dropdown position */
            .nav-style6.active {
                right: 0.75rem;
                min-width: 200px;
            }
            
            .nav-style6 a {
                font-size: 0.9rem;
                padding: 0.625rem 1rem;
            }
            
            /* Logo - same as 768px breakpoint */
            .header .logo {
                display: flex;
            }
            
            .header .logo img {
                height: 32px;
                max-width: 120px;
                display: block;
            }
        }
        
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Admin-specific styles */
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f5f7fa;
            color: #1f2933;
        }

        /* Mobile Dropdown Menu */
        .mobile-admin-menu {
            display: none;
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 1rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            min-width: 220px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            z-index: 1000;
            flex-direction: column;
            align-items: stretch;
            gap: 0;
        }

        .mobile-admin-menu.active {
            display: flex;
            max-height: 300px;
            opacity: 1;
        }

        .mobile-admin-menu-item {
            padding: 0.75rem 1.25rem;
            color: #1f2933;
            font-size: 0.95rem;
            border-bottom: 1px solid #e5e7eb;
            text-decoration: none;
            transition: all 0.2s;
        }

        .mobile-admin-menu-item:last-child {
            border-bottom: none;
            border-radius: 0 0 12px 12px;
        }

        .mobile-admin-menu-item:hover {
            background: #f5f7fa;
            color: #0b7285;
            padding-left: 1.5rem;
        }

        .mobile-admin-menu-item.logout {
            color: #dc2626;
            font-weight: 600;
        }

        .mobile-admin-menu-item.logout:hover {
            background: #fee2e2;
            color: #991b1b;
        }
        
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f7fa;
      color: #1f2933;
    }

    /* Header styles now handled by unified-header.css */
    /* Admin-specific overrides only */

    /* Mobile Dropdown Menu */
    .mobile-admin-menu {
      display: none;
      position: absolute;
      top: calc(100% + 0.5rem);
      right: 1rem;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      min-width: 220px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      opacity: 0;
      z-index: 1000;
      flex-direction: column;
      align-items: stretch;
      gap: 0;
    }

    .mobile-admin-menu.active {
      display: flex;
      max-height: 300px;
      opacity: 1;
    }

    .mobile-admin-menu-item {
      padding: 0.75rem 1.25rem;
      color: #1f2933;
      font-size: 0.95rem;
      border-bottom: 1px solid #e5e7eb;
      text-decoration: none;
      transition: all 0.2s;
    }

    .mobile-admin-menu-item:last-child {
      border-bottom: none;
      border-radius: 0 0 12px 12px;
    }

    .mobile-admin-menu-item:hover {
      background: #f5f7fa;
      color: #0b7285;
      padding-left: 1.5rem;
    }

    .mobile-admin-menu-item.logout {
      color: #dc2626;
      font-weight: 600;
    }

    .mobile-admin-menu-item.logout:hover {
      background: #fee2e2;
      color: #991b1b;
    }

    main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 768px) {
      /* Override header-responsive-fixes.css grid rules */
      .header-top,
      .header-top[style*="grid"],
      .header-top.grid {
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        padding: 0.875rem 1rem !important;
        position: relative !important;
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
        overflow: visible !important;
        gap: 0.5rem !important;
        grid-template-columns: none !important;
      }

      .header-left,
      .header-top .header-left {
        position: absolute !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 1 !important;
        pointer-events: auto !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        grid-column: auto !important;
        justify-self: auto !important;
        top: auto !important;
      }

      .brand {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        max-width: 140px !important;
        width: auto !important;
        overflow: visible !important;
      }

      .brand img {
        height: 32px !important;
        max-width: 120px !important;
        width: auto !important;
        object-fit: contain !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        filter: brightness(0) invert(1) !important;
      }

      .header-center {
        display: none !important;
      }

      .header-right {
        display: none !important;
      }

      .menu-toggle-style6 {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        flex-shrink: 0 !important;
        width: 44px !important;
        height: 44px !important;
        padding: 0.5rem !important;
        align-items: center !important;
        justify-content: center !important;
        border-radius: 8px !important;
        order: 1 !important;
        z-index: 2 !important;
        box-sizing: border-box !important;
        position: static !important;
        left: auto !important;
        margin: 0 !important;
        background: rgba(255, 255, 255, 0.1) !important;
        border: 1px solid rgba(255, 255, 255, 0.2) !important;
        color: #ffffff !important;
        cursor: pointer !important;
        transition: background-color 0.2s !important;
        min-width: 44px !important;
        min-height: 44px !important;
      }

      .mobile-admin-menu {
        display: flex;
      }

      main {
        padding: 1rem;
      }

      .page-header {
        margin-bottom: 1.5rem;
        text-align: left;
      }

      .page-header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.25rem;
      }

      .page-header p {
        font-size: 0.9rem;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
        margin-bottom: 1.5rem;
      }

      .stat-card {
        padding: 0.75rem;
        border-radius: 8px;
      }

      .stat-value {
        font-size: 1.5rem;
        margin-bottom: 0.25rem;
      }

      .stat-label {
        font-size: 0.8rem;
        font-weight: 500;
      }

      .filters {
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        position: relative;
        z-index: 1;
        margin-bottom: 1.5rem;
      }

      .filters label {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        position: relative;
        z-index: 1;
        font-size: 0.9rem;
        font-weight: 500;
        color: #374151;
      }

      .filters label:first-child {
        z-index: 101;
      }

      .filters label .custom-select-wrapper {
        width: 100%;
        margin-top: 0;
        display: block !important;
      }

      .filters label select {
        display: none !important;
      }

      .filters select,
      .filters input,
      .custom-select-trigger {
        width: 100%;
        font-size: 1rem;
        padding: 0.75rem;
        min-height: 44px;
        -webkit-appearance: none;
        appearance: none;
        position: relative;
        z-index: 100;
        border: 1px solid #cbd2e1;
        border-radius: 6px;
        background: #fff;
        box-sizing: border-box;
      }

      .filters input {
        display: block;
      }

      .custom-select-trigger {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
      }

      .filters button {
        width: 100%;
        min-height: 44px;
        font-size: 1rem;
        padding: 0.75rem 1rem;
        font-weight: 500;
        border-radius: 6px;
      }

      .applications-list {
        border-radius: 0;
        overflow: visible;
      }

      .application-item {
        padding: 1rem;
        border-bottom: 1px solid #e5e7eb;
      }

      .application-item:last-child {
        border-bottom: none;
      }

    }

    @media (max-width: 480px) {
      main {
        padding: 0.75rem;
      }

      /* Override header-responsive-fixes.css grid rules */
      .header-top,
      .header-top[style*="grid"],
      .header-top.grid {
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        padding: 0.875rem 1rem !important;
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
        overflow: visible !important;
        gap: 0.5rem !important;
        grid-template-columns: none !important;
      }

      .header-left {
        position: absolute !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 1 !important;
        pointer-events: auto !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        top: auto !important;
      }

      .brand {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        max-width: 140px !important;
        width: auto !important;
        overflow: visible !important;
      }

      .brand img {
        height: 32px !important;
        max-width: 120px !important;
        width: auto !important;
        object-fit: contain !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        filter: brightness(0) invert(1) !important;
      }

      .menu-toggle-style6 {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        width: 44px !important;
        height: 44px !important;
        min-width: 44px !important;
        min-height: 44px !important;
        padding: 0.5rem !important;
        order: 1 !important;
        position: static !important;
      }

      .page-header h1 {
        font-size: 1.25rem;
      }

      .stats-grid {
        grid-template-columns: 1fr;
        gap: 0.625rem;
      }

      .stat-card {
        padding: 0.625rem;
      }

      .stat-value {
        font-size: 1.25rem;
      }

      .stat-label {
        font-size: 0.75rem;
      }

      .filters {
        padding: 0.875rem;
        gap: 0.875rem;
      }

      .filters label {
        font-size: 0.875rem;
      }

      .filters select,
      .filters input {
        font-size: 0.9375rem;
        padding: 0.625rem;
      }

      .custom-select-trigger {
        font-size: 0.9375rem;
        padding: 0.625rem;
        min-height: 44px;
      }

      .custom-select-option {
        font-size: 0.9375rem;
        padding: 0.75rem;
      }

      .application-item {
        padding: 0.875rem;
        position: relative;
      }
      
      .application-item button {
        min-height: 44px;
        touch-action: manipulation;
      }

      .application-info h3 {
        font-size: 1rem;
      }

      .mobile-admin-menu {
        right: 0.75rem;
        min-width: 200px;
        max-width: calc(100vw - 1.5rem);
      }

      .mobile-admin-menu-item {
        font-size: 0.9rem;
        padding: 0.625rem 1rem;
      }
    }

    .page-header {
      margin-bottom: 2rem;
      text-align: center;
    }

    .page-header h1 {
      margin: 0 0 0.5rem 0;
      color: #0b7285;
    }

    .page-header p {
      color: #6b7280;
      margin: 0;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      position: relative;
      z-index: 1;
    }

    .stat-card {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #0b7285;
      margin-bottom: 0.25rem;
    }

    .stat-label {
      color: #6b7280;
      font-size: 0.85rem;
    }

    .filters {
      background: #fff;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: flex-start;
    }
    
    .filters label {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filters label:not(:has(button)) {
      min-width: 150px;
    }

    .filters select, .filters input {
      padding: 0.5rem;
      border: 1px solid #cbd2e1;
      border-radius: 6px;
      font-size: 0.9rem;
      background: #fff;
      position: relative;
      z-index: 10;
      width: 100%;
    }

    .filters select {
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      padding-right: 2.5rem;
    }

    /* Custom Mobile Dropdown */
    .custom-select-wrapper {
      position: relative;
      width: 100%;
      display: none;
    }

    .custom-select-trigger {
      width: 100%;
      padding: 0.5rem;
      min-height: auto;
      font-size: 0.9rem;
      border: 1px solid #cbd2e1;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      z-index: 10;
      box-sizing: border-box;
    }

    .custom-select-trigger::after {
      content: '▼';
      font-size: 0.75rem;
      color: #333;
      transition: transform 0.3s;
    }

    .custom-select-trigger.active::after {
      transform: rotate(180deg);
    }

    .custom-select-options {
      display: none;
      position: absolute;
      top: calc(100% + 0.25rem);
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #cbd2e1;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      z-index: 1000;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 0.25rem;
      -webkit-overflow-scrolling: touch;
    }

    .custom-select-options.active {
      display: block;
    }

    .custom-select-option {
      padding: 0.875rem 1rem;
      cursor: pointer;
      font-size: 1rem;
      color: #1f2933;
      border-bottom: 1px solid #f3f4f6;
      transition: background 0.2s;
    }

    .custom-select-option:last-child {
      border-bottom: none;
    }

    .custom-select-option:hover,
    .custom-select-option.selected {
      background: #f0f9ff;
      color: #0b7285;
    }

    /* Hide native select on mobile, show custom */
    @media (max-width: 768px) {
      .filters select {
        display: none !important;
      }

      .custom-select-wrapper,
      .filters label .custom-select-wrapper {
        display: block !important;
      }
    }

    /* Show native select on desktop, hide custom */
    @media (min-width: 769px) {
      .custom-select-wrapper,
      .filters label .custom-select-wrapper {
        display: none !important;
      }

      .filters select {
        display: block !important;
      }
    }

    .applications-list {
      background: transparent;
      border-radius: 0;
      box-shadow: none;
      overflow: visible;
    }

    .application-item {
      background: #fff;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      pointer-events: auto;
    }

    .application-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
    }

    .application-info h3 {
      font-size: 1.125rem;
      font-weight: 600;
      color: #111827;
      margin-bottom: 0.5rem;
    }

    .practice-number {
      color: #6b7280;
      font-size: 0.875rem;
    }

    .applicant-name {
      color: #6b7280;
      font-size: 0.875rem;
      margin-top: 0.25rem;
    }
    
    .client-count {
      color: #059669;
      font-size: 0.85rem;
      margin-top: 0.5rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .btn-secondary {
      background: #6b7280;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-secondary:hover {
      background: #4b5563;
    }

    .application-actions {
      margin-bottom: 0.75rem;
      display: flex;
      gap: 0.5rem;
      justify-content: flex-start;
      flex-wrap: wrap;
      position: relative;
      z-index: 10;
      pointer-events: auto;
    }
    
    .application-actions button {
      position: relative;
      z-index: 11;
      touch-action: manipulation;
      -webkit-tap-highlight-color: rgba(11, 114, 133, 0.3);
      cursor: pointer;
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
    }
    
    .btn-fraud {
      background: #b45309;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-fraud:hover {
      background: #92400e;
    }
    
    .btn-delete {
      background: #7f1d1d;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-delete:hover {
      background: #6b1a1a;
    }
    
    .btn-clear-fraud {
      background: #10b981;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-clear-fraud:hover {
      background: #059669;
    }
    
    .header-action-btn {
      margin-left: auto;
    }
    
    .suspend-btn {
      z-index: 20 !important;
      position: relative !important;
    }

    .expand-toggle {
      background: none;
      border: none;
      color: #0b7285;
      font-size: 0.875rem;
      cursor: pointer;
      padding: 0.5rem 0 0 0;
      width: 100%;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
      z-index: 5;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      margin-top: 0.5rem;
    }

    .expand-toggle:hover {
      color: #095a69;
    }

    .expand-icon {
      transition: transform 0.3s;
    }

    .expand-icon.expanded {
      transform: rotate(180deg);
    }

    .expandable-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .expandable-content.expanded {
      max-height: 2000px;
    }

    .details-section {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      padding: 0.75rem 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .detail-row:last-child {
      border-bottom: none;
    }

    .detail-label {
      font-weight: 600;
      color: #374151;
      font-size: 0.875rem;
    }

    .detail-value {
      color: #111827;
      font-size: 0.875rem;
      text-align: right;
    }

    .specializations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.25rem;
      justify-content: flex-end;
    }

    .specialization-tag {
      background: #dbeafe;
      color: #1e40af;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.75rem;
    }

    /* Desktop: Button compact, expandable section visible */
    @media (min-width: 769px) {
      .application-actions {
        justify-content: flex-start;
      }

      .application-actions button {
        width: auto;
        padding: 0.625rem 1.25rem;
        font-size: 0.875rem;
      }

      .expand-toggle {
        display: flex;
      }

      .application-details {
        display: none;
      }

      .detail-row {
        display: flex;
        justify-content: space-between;
      }

      .detail-value {
        text-align: right;
      }
    }

    /* Mobile: Button full-width, expandable section visible */
    @media (max-width: 768px) {
      .application-actions {
        justify-content: stretch;
      }

      .application-actions button {
        width: 100%;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
        min-height: 44px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(11, 114, 133, 0.2);
        position: relative;
        z-index: 15;
      }

      .expand-toggle {
        display: flex;
      }

      .application-details {
        display: none;
      }

      .detail-row {
        flex-direction: column;
        gap: 0.25rem;
      }

      .detail-value {
        text-align: left;
      }
    }


    .application-status {
      padding: 0.375rem 0.75rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .status-pending {
      background: #fef3c7;
      color: #92400e;
    }

    .status-approved {
      background: #d1fae5;
      color: #065f46;
    }

    .status-suspended {
      background: #fef3c7;
      color: #92400e;
    }
    
    .status-fraud {
      background: #fee2e2;
      color: #991b1b;
    }

    .status-rejected {
      background: #fee2e2;
      color: #991b1b;
    }


    .specializations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .specialization-tag {
      background: #e0f2fe;
      color: #0b7285;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.8rem;
    }

    .application-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
      position: relative;
      z-index: 10;
    }

    .btn-primary {
      background: #0b7285;
      color: #fff;
    }

    .btn-primary:hover {
      background: #095a69;
    }

    .btn-danger {
      background: #dc2626;
      color: #fff;
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    .btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }

    .alert {
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      display: none;
    }

    .alert.show {
      display: block;
    }

    .alert-success {
      background: #d1fae5;
      color: #065f46;
      border: 1px solid #6ee7b7;
    }

    .alert-error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fca5a5;
    }

    .loading {
      text-align: center;
      padding: 3rem;
      color: #6b7280;
    }

    .empty-state {
      text-align: center;
      padding: 3rem;
      color: #6b7280;
    }

    .empty-state h3 {
      margin-bottom: 0.5rem;
      color: #111827;
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-top">
      <button class="menu-toggle-style6" id="menuToggle" onclick="toggleMenuStyle6()" aria-label="Toggle navigation menu">☰</button>
      <div class="logo">
        <img src="assets/images/full%20logo%20CT.png" alt="ClearTrack Logo">
      </div>
      <button class="btn btn-outline" onclick="window.location.href='/login.html'" style="background: rgba(255,255,255,0.2); color: #ffffff; border-color: rgba(255,255,255,0.3);" id="desktopLogoutBtn">Logout</button>
    </div>
    <nav class="nav nav-style6" id="mainNav">
      <span class="nav-title">Admin Dashboard</span>
      <button class="btn btn-secondary header-action-btn" onclick="window.reassignClientsFromFraudTaggedPractitioners(); return false;" title="Reassign clients from fraud-tagged practitioners past their appeal deadline">Reassign Fraud Clients</button>
    </nav>
  </header>
  
  <main>
    <div class="page-header">
      <h1>Practitioner Applications</h1>
      <p>Review and manage practitioner registration applications</p>
    </div>

    <div id="alert" class="alert"></div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-value" id="statPending">-</div>
        <div class="stat-label">Pending</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="statApproved">-</div>
        <div class="stat-label">Approved</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="statSuspended">-</div>
        <div class="stat-label">Suspended</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="statRejected">-</div>
        <div class="stat-label">Rejected</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="statTotal">-</div>
        <div class="stat-label">Total</div>
      </div>
    </div>

    <div class="filters">
      <label>
        Status:
        <select id="filterStatus">
          <option value="all">All</option>
          <option value="pending">Pending</option>
          <option value="approved">Approved</option>
          <option value="suspended">Suspended</option>
          <option value="fraud">Fraud</option>
          <option value="rejected">Rejected</option>
        </select>
        <div class="custom-select-wrapper">
          <div class="custom-select-trigger" id="customSelectTrigger">
            <span id="customSelectText">All</span>
          </div>
          <div class="custom-select-options" id="customSelectOptions">
            <div class="custom-select-option selected" data-value="all">All</div>
            <div class="custom-select-option" data-value="pending">Pending</div>
            <div class="custom-select-option" data-value="approved">Approved</div>
            <div class="custom-select-option" data-value="suspended">Suspended</div>
            <div class="custom-select-option" data-value="fraud">Fraud</div>
            <div class="custom-select-option" data-value="rejected">Rejected</div>
          </div>
        </div>
      </label>
      <label>
        <span>Search:</span>
        <input type="text" id="filterSearch" placeholder="Name, email, practice...">
      </label>
      <div style="display: flex; flex-direction: column; gap: 0.5rem;">
        <span style="opacity: 0; height: 1.2rem;">Placeholder</span>
        <button class="btn btn-primary" onclick="loadApplications()">Refresh</button>
      </div>
    </div>

    <div class="applications-list" id="applicationsList">
      <div class="loading">Loading applications...</div>
    </div>
  </main>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-functions-compat.js"></script>

  <script src="firebase-config.js"></script>
  <script src="firebase-init.js"></script>
  <script src="firebase-api.js"></script>
  <script src="dashboard-auth.js"></script>

  <script>
    // CRITICAL: This must execute immediately
    try {
      window.adminDashboardScriptLoaded = true;
    } catch(e) {
      console.error('[admin-dashboard] ERROR in immediate script:', e);
    }
    
    let allApplications = [];

    // Set admin email - dashboard-auth.js already handles authentication
    async function initializeAdminDashboard() {
      try {
        // Wait for Firebase to be ready
        if (!window.firebaseAuth || !window.firebaseDb) {
          console.error('[initializeAdminDashboard] Firebase not initialized');
          return false;
        }


        // Get current user
        const user = window.firebaseAuth.currentUser;
        if (user) {
          const emailEl = document.getElementById('adminEmail');
          if (emailEl) {
            emailEl.textContent = user.email;
          }
          const mobileEmailEl = document.getElementById('mobileAdminEmail');
          if (mobileEmailEl) {
            mobileEmailEl.textContent = user.email;
          }
          return true;
        }

        // If no user yet, wait for auth state
        return new Promise((resolve) => {
          const unsubscribe = window.firebaseAuth.onAuthStateChanged(async (user) => {
            unsubscribe(); // Only run once
            if (user) {
              const emailEl = document.getElementById('adminEmail');
              if (emailEl) {
                emailEl.textContent = user.email;
              }
              const mobileEmailEl = document.getElementById('mobileAdminEmail');
              if (mobileEmailEl) {
                mobileEmailEl.textContent = user.email;
              }
              resolve(true);
            } else {
              console.error('[initializeAdminDashboard] No user after auth state change');
              resolve(false);
            }
          });
        });
      } catch (error) {
        console.error('[initializeAdminDashboard] Error initializing admin dashboard:', error);
        console.error('[initializeAdminDashboard] Error stack:', error.stack);
        return false;
      }
    }

    function showAlert(message, type) {
      const alert = document.getElementById('alert');
      alert.textContent = message;
      alert.className = `alert alert-${type} show`;
      setTimeout(() => {
        alert.classList.remove('show');
      }, 5000);
    }

    async function loadApplications() {
      try {
        const listEl = document.getElementById('applicationsList');
        if (!listEl) {
          console.error('[loadApplications] applicationsList element not found!');
          return;
        }
        listEl.innerHTML = '<div class="loading">Loading applications...</div>';

        // Load from Firestore
        const snapshot = await window.firebaseDb.collection('practitionerApplications')
          .orderBy('createdAt', 'desc')
          .get();

        allApplications = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          allApplications.push({
            id: doc.id,
            ...data,
            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt),
            userPractitionerStatus: null // Initialize, will be set below if approved
          });
        });

        // Fetch user practitionerStatus for approved applications AND check all apps for fraud status
        const approvedApps = allApplications.filter(app => {
          const isApproved = app.status === 'approved' || (app.status && app.status.toLowerCase() === 'approved');
          return isApproved && app.email;
        });
        
        // Also check ALL applications for fraud status (not just approved ones)
        const appsWithEmail = allApplications.filter(app => app.email);
        
        if (appsWithEmail.length > 0) {
          try {
            // Check fraud status for all apps with email
            for (const app of appsWithEmail) {
              try {
                let userSnapshot = await window.firebaseDb.collection('users')
                  .where('email', '==', app.email)
                  .limit(1)
                  .get();
                
                if (userSnapshot.empty && app.email.trim() !== app.email) {
                  userSnapshot = await window.firebaseDb.collection('users')
                    .where('email', '==', app.email.trim())
                    .limit(1)
                    .get();
                }
                
                if (userSnapshot.empty) {
                  userSnapshot = await window.firebaseDb.collection('users')
                    .where('email', '==', app.email.toLowerCase().trim())
                    .limit(1)
                    .get();
                }
                
                if (!userSnapshot.empty) {
                  const userData = userSnapshot.docs[0].data();
                  // Check if fraud-tagged
                  if (userData.fraudTagged === true || userData.practitionerStatus === 'fraud') {
                    app.userPractitionerStatus = 'fraud';
                  }
                }
              } catch (fraudCheckError) {
                // Continue if fraud check fails
                console.warn('Error checking fraud status for', app.email, ':', fraudCheckError);
              }
            }
          } catch (error) {
            console.warn('Error checking fraud status:', error);
          }
        }
        
        if (approvedApps.length > 0) {
          try {
            const userStatusMap = {};
            
            // Query each approved app's email individually to get status
            for (const app of approvedApps) {
              if (!app.email) {
                app.userPractitionerStatus = 'approved';
                app.clientCount = 0;
                continue;
              }
              
              try {
                // Try exact email first, then variations
                let userSnapshot = await window.firebaseDb.collection('users')
                  .where('email', '==', app.email)
                  .limit(1)
                  .get();
                
                // If not found, try trimmed
                if (userSnapshot.empty && app.email.trim() !== app.email) {
                  userSnapshot = await window.firebaseDb.collection('users')
                    .where('email', '==', app.email.trim())
                    .limit(1)
                    .get();
                }
                
                // If still not found, try lowercase
                if (userSnapshot.empty) {
                  userSnapshot = await window.firebaseDb.collection('users')
                    .where('email', '==', app.email.toLowerCase().trim())
                    .limit(1)
                    .get();
                }
                
                if (!userSnapshot.empty) {
                  const userData = userSnapshot.docs[0].data();
                  const userId = userSnapshot.docs[0].id;
                  // Check for fraud status first (fraudTagged flag OR practitionerStatus === 'fraud')
                  if (userData.fraudTagged === true || userData.practitionerStatus === 'fraud') {
                    app.userPractitionerStatus = 'fraud';
                    userStatusMap[app.email] = 'fraud';
                  } else {
                    // Read the actual status - if undefined/null, default to 'approved'
                    const rawStatus = userData.practitionerStatus;
                    const status = (rawStatus !== undefined && rawStatus !== null) ? rawStatus : 'approved';
                    app.userPractitionerStatus = status;
                    userStatusMap[app.email] = status;
                  }
                  
                  // Get client count for this practitioner
                  try {
                    const clientsSnapshot = await window.firebaseDb.collection('users')
                      .where('connectedPractitioner', '==', userId)
                      .get();
                    app.clientCount = clientsSnapshot.size;
                  } catch (clientCountError) {
                    console.warn('Error getting client count for', app.email, ':', clientCountError);
                    app.clientCount = 0;
                  }
                } else {
                  // User not found, default to approved
                  app.userPractitionerStatus = 'approved';
                  app.clientCount = 0;
                }
              } catch (queryError) {
                // If query fails, default to approved
                app.userPractitionerStatus = 'approved';
                app.clientCount = 0;
              }
            }
          } catch (error) {
            // If lookup fails, default all to 'approved'
            approvedApps.forEach(app => {
              app.userPractitionerStatus = 'approved';
              app.clientCount = 0;
            });
          }
        }
        
        // Ensure all approved apps have userPractitionerStatus set
        allApplications.forEach(app => {
          const isApproved = app.status === 'approved' || (app.status && app.status.toLowerCase() === 'approved');
          if (isApproved && !app.userPractitionerStatus) {
            app.userPractitionerStatus = 'approved';
          }
          // If fraud status was already set, keep it (don't override)
          // This ensures fraud-tagged practitioners keep their fraud status
        });

        // Sort by createdAt descending
        allApplications.sort((a, b) => b.createdAt - a.createdAt);


        updateStats();
        renderApplications();
      } catch (error) {
        console.error('Error loading applications:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        console.error('Firebase project ID:', window.firebaseDb?.app?.options?.projectId);
        console.error('Collection path:', 'practitionerApplications');
        document.getElementById('applicationsList').innerHTML = 
          '<div class="empty-state"><h3>Error</h3><p>Failed to load applications. Please refresh.</p></div>';
      }
    }

    function updateStats() {
      const pending = allApplications.filter(a => a.status === 'pending').length;
      const approved = allApplications.filter(a => {
        const isApproved = a.status === 'approved' || (a.status && String(a.status).toLowerCase() === 'approved');
        return isApproved && a.userPractitionerStatus !== 'suspended' && a.userPractitionerStatus !== 'fraud';
      }).length;
      const suspended = allApplications.filter(a => {
        const isApproved = a.status === 'approved' || (a.status && String(a.status).toLowerCase() === 'approved');
        return isApproved && a.userPractitionerStatus === 'suspended';
      }).length;
      const fraud = allApplications.filter(a => {
        return a.userPractitionerStatus === 'fraud';
      }).length;
      const rejected = allApplications.filter(a => a.status === 'rejected').length;

      document.getElementById('statPending').textContent = pending;
      document.getElementById('statApproved').textContent = approved;
      document.getElementById('statSuspended').textContent = suspended;
      document.getElementById('statRejected').textContent = rejected;
      document.getElementById('statTotal').textContent = allApplications.length;
    }

    function renderApplications() {
      const statusFilter = document.getElementById('filterStatus').value;
      const searchFilter = document.getElementById('filterSearch').value.toLowerCase();

      let filtered = allApplications;

      if (statusFilter !== 'all') {
        if (statusFilter === 'suspended') {
          // Filter for approved applications that are suspended
          filtered = filtered.filter(a => {
            const isApproved = a.status === 'approved' || (a.status && String(a.status).toLowerCase() === 'approved');
            return isApproved && a.userPractitionerStatus === 'suspended';
          });
        } else if (statusFilter === 'fraud') {
          // Filter for fraud-tagged practitioners
          filtered = filtered.filter(a => {
            return a.userPractitionerStatus === 'fraud';
          });
        } else if (statusFilter === 'approved') {
          // Filter for approved applications that are NOT suspended and NOT fraud
          filtered = filtered.filter(a => {
            const isApproved = a.status === 'approved' || (a.status && String(a.status).toLowerCase() === 'approved');
            return isApproved && a.userPractitionerStatus !== 'suspended' && a.userPractitionerStatus !== 'fraud';
          });
        } else {
        filtered = filtered.filter(a => a.status === statusFilter);
        }
      }

      if (searchFilter) {
        filtered = filtered.filter(a => 
          a.firstName?.toLowerCase().includes(searchFilter) ||
          a.lastName?.toLowerCase().includes(searchFilter) ||
          a.email?.toLowerCase().includes(searchFilter) ||
          a.practiceName?.toLowerCase().includes(searchFilter)
        );
      }

      const listEl = document.getElementById('applicationsList');

      if (filtered.length === 0) {
        listEl.innerHTML = '<div class="empty-state"><h3>No applications found</h3><p>No applications match your filters.</p></div>';
        return;
      }

      // Helper function to escape HTML
      const escapeHtml = (text) => {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      };
      
      listEl.innerHTML = filtered.map(app => {
        const appId = app.id || Math.random().toString(36).substr(2, 9);
        const isApprovedForButton = (app.status === 'approved' || (app.status && String(app.status).toLowerCase() === 'approved')) && !!app.email;
        const isSuspended = app.userPractitionerStatus === 'suspended';
        const isFraudTagged = app.userPractitionerStatus === 'fraud';
        // Show buttons for approved practitioners OR fraud-tagged practitioners (they need the clear fraud button)
        const showActionButtons = isApprovedForButton || (isFraudTagged && !!app.email);
        const escapedEmail = escapeHtml(app.email || '');
        const safeEmail = escapedEmail.replace(/'/g, "\\'");
        // Direct onclick handler - simple and reliable
        const suspendButton = isSuspended
          ? `<button class="btn btn-primary suspend-btn" data-action="reactivate" data-email="${escapedEmail}" onclick="event.stopPropagation(); window.reactivatePractitionerByEmail('${safeEmail}'); return false;" type="button">Reactivate</button>`
          : `<button class="btn btn-danger suspend-btn" data-action="suspend" data-email="${escapedEmail}" onclick="event.stopPropagation(); window.suspendPractitionerByEmail('${safeEmail}'); return false;" type="button">Suspend</button>`;
        const clearFraudButton = isFraudTagged
          ? `<button class="btn btn-clear-fraud" data-action="clear-fraud" data-email="${escapedEmail}" onclick="event.stopPropagation(); window.clearFraudTag('${safeEmail}'); return false;" type="button">Clear Fraud Tag</button>`
          : '';
        
        const fraudButton = !isFraudTagged
          ? `<button class="btn btn-fraud" data-action="fraud" data-email="${escapedEmail}" onclick="event.stopPropagation(); window.tagPractitionerAsFraud('${safeEmail}'); return false;" type="button">Tag as Fraud</button>`
          : '';
        
        const statusText = isSuspended ? 'SUSPENDED' : (isFraudTagged ? 'FRAUD' : app.status);
        const statusClass = isSuspended ? 'suspended' : (isFraudTagged ? 'fraud' : app.status);
        
        return `
        <div class="application-item">
          <div class="application-header">
            <div class="application-info">
              <h3>${app.practiceName || 'N/A'}</h3>
              <div class="practice-number">${app.practiceNumber || 'N/A'}</div>
              <div class="applicant-name">${app.firstName} ${app.lastName}</div>
              ${(isApprovedForButton || isFraudTagged) && app.clientCount !== undefined ? `<div class="client-count">👥 ${app.clientCount} ${app.clientCount === 1 ? 'client' : 'clients'}</div>` : ''}
              </div>
            <span class="application-status status-${statusClass}">${statusText}</span>
            </div>
          
          ${showActionButtons ? `
          <div class="application-actions">
            ${!isFraudTagged ? suspendButton : ''}
            ${isFraudTagged ? clearFraudButton : fraudButton}
            <button class="btn btn-delete" data-action="delete" data-email="${escapedEmail}" onclick="event.stopPropagation(); window.deletePractitioner('${safeEmail}'); return false;" type="button">Delete</button>
          </div>
          ` : ''}
          
          ${app.status === 'pending' ? `
          <div class="application-actions">
            <button class="btn btn-primary" data-action="approve" data-app-id="${app.id}" onclick="event.stopPropagation(); approveApplication('${app.id}'); return false;" type="button">Approve</button>
            <button class="btn btn-danger" data-action="reject" data-app-id="${app.id}" onclick="event.stopPropagation(); rejectApplication('${app.id}'); return false;" type="button">Reject</button>
          </div>
          ` : ''}
          
          <button class="expand-toggle" data-action="toggle" data-app-id="${appId}" onclick="event.stopPropagation(); toggleApplicationDetails('${appId}'); return false;" type="button">
            <span class="expand-icon" id="icon-${appId}">▼</span>
            <span id="text-${appId}">More Details</span>
          </button>
          
          <div class="expandable-content" id="details-${appId}">
            <div class="details-section">
              <div class="detail-row">
                <span class="detail-label">Name:</span>
                <span class="detail-value">${app.firstName} ${app.lastName}</span>
              </div>
              
              <div class="detail-row">
                <span class="detail-label">Email:</span>
                <span class="detail-value">${app.email || 'N/A'}</span>
              </div>
              
              <div class="detail-row">
                <span class="detail-label">Practice Name:</span>
                <span class="detail-value">${app.practiceName || 'N/A'}</span>
              </div>
              
              <div class="detail-row">
                <span class="detail-label">Date:</span>
                <span class="detail-value">${app.createdAt ? app.createdAt.toLocaleDateString() : 'N/A'}</span>
              </div>
              
            <div class="detail-row">
              <span class="detail-label">Phone:</span>
              <span class="detail-value">${app.phone || 'N/A'}</span>
            </div>
              
            <div class="detail-row">
              <span class="detail-label">Practice Number:</span>
              <span class="detail-value">${app.practiceNumber || 'N/A'}</span>
            </div>
              
            <div class="detail-row">
              <span class="detail-label">SARS Number:</span>
              <span class="detail-value">${app.sarsNumber || 'N/A'}</span>
            </div>
              
            <div class="detail-row">
              <span class="detail-label">Experience:</span>
                <span class="detail-value">${app.yearsExperience || 0} years</span>
            </div>
              
            <div class="detail-row">
              <span class="detail-label">Qualifications:</span>
              <span class="detail-value">${app.qualifications || 'N/A'}</span>
            </div>
              
            <div class="detail-row">
              <span class="detail-label">Specializations:</span>
                <span class="detail-value">
                <div class="specializations">
                  ${(app.specializations || []).map(s => `<span class="specialization-tag">${s}</span>`).join('')}
                </div>
                </span>
              </div>
              
            ${app.bio ? `
            <div class="detail-row">
              <span class="detail-label">Bio:</span>
              <span class="detail-value">${app.bio}</span>
            </div>
            ` : ''}
              
            ${app.message ? `
            <div class="detail-row">
              <span class="detail-label">Message:</span>
              <span class="detail-value">${app.message}</span>
            </div>
            ` : ''}
          </div>
          </div>
        </div>
      `;
      }).join('');
      
      // Set up event delegation immediately after rendering
      setupApplicationEventDelegation();
    }
    
    // Event delegation for application buttons - works better on mobile
    // This is set up once and handles all dynamically created buttons
    function setupApplicationEventDelegation() {
      console.log('[setupApplicationEventDelegation] Setting up event delegation...');
      const applicationsList = document.getElementById('applicationsList');
      if (!applicationsList) {
        console.warn('[setupApplicationEventDelegation] applicationsList not found');
        return;
      }
      
      console.log('[setupApplicationEventDelegation] applicationsList found:', applicationsList);
      
      // Remove existing listeners if any
      if (applicationsList._clickHandler) {
        applicationsList.removeEventListener('click', applicationsList._clickHandler, false);
        applicationsList.removeEventListener('touchend', applicationsList._clickHandler, false);
      }
      
      // Create handler that works for both click and touch
      const eventHandler = function(e) {
        console.log('[Event Handler] Event triggered:', e.type, e.target);
        
        const target = e.target || (e.changedTouches && e.changedTouches[0] && e.changedTouches[0].target);
        if (!target) {
          console.log('[Event Handler] No target');
          return;
        }
        
        const button = target.closest('button[data-action]');
        if (!button) {
          console.log('[Event Handler] No button found, target:', target.tagName, target.className);
          return;
        }
        
        console.log('[Event Handler] Button found:', button.getAttribute('data-action'));
        
        e.preventDefault();
        e.stopPropagation();
        
        const action = button.getAttribute('data-action');
        const email = button.getAttribute('data-email');
        const appId = button.getAttribute('data-app-id');
        
        console.log('[Event Handler] Button clicked:', action, email);
        
        switch(action) {
          case 'suspend':
            if (email && window.suspendPractitionerByEmail) {
              console.log('[Event Handler] Calling suspend function with email:', email);
              window.suspendPractitionerByEmail(email);
            } else {
              console.error('[Event Handler] Missing email or function not found. Email:', email, 'Function exists:', !!window.suspendPractitionerByEmail);
            }
            break;
          case 'reactivate':
            if (email && window.reactivatePractitionerByEmail) {
              window.reactivatePractitionerByEmail(email);
            }
            break;
          case 'delete':
            if (email && window.deletePractitioner) {
              window.deletePractitioner(email);
            }
            break;
          case 'fraud':
            if (email && window.tagPractitionerAsFraud) {
              window.tagPractitionerAsFraud(email);
            }
            break;
          case 'approve':
            if (appId) {
              approveApplication(appId);
            }
            break;
          case 'reject':
            if (appId) {
              rejectApplication(appId);
            }
            break;
          case 'toggle':
            if (appId) {
              toggleApplicationDetails(appId);
            }
            break;
        }
      };
      
      // Store reference to handler for cleanup
      applicationsList._clickHandler = eventHandler;
      
      // Attach click events
      applicationsList.addEventListener('click', eventHandler, false);
      applicationsList.addEventListener('touchend', eventHandler, false);
      
      console.log('[setupApplicationEventDelegation] Event delegation set up on:', applicationsList);
    }

    /**
     * Generate a unique practitioner code
     * Checks against existing codes in Firestore to ensure uniqueness
     */
    async function generateUniquePractitionerCode() {
      const db = window.firebaseDb || firebase.firestore();
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusing chars (0, O, I, 1)
      let code = '';
      let isUnique = false;
      let attempts = 0;
      const maxAttempts = 50;
      
      while (!isUnique && attempts < maxAttempts) {
        // Generate 8-character code
        code = '';
        for (let i = 0; i < 8; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        
        // Check if code already exists in Firestore
        try {
          const existingPractitioners = await db.collection('users')
            .where('role', '==', 'practitioner')
            .where('practitionerCode', '==', code)
            .limit(1)
            .get();
          
          if (existingPractitioners.empty) {
            isUnique = true;
          } else {
            attempts++;
            console.log(`[generateUniquePractitionerCode] Code ${code} already exists, generating new one...`);
          }
        } catch (error) {
          console.warn('[generateUniquePractitionerCode] Error checking code uniqueness:', error);
          // If we can't check, assume it's unique and proceed
          isUnique = true;
        }
      }
      
      if (!isUnique) {
        throw new Error('Failed to generate unique practitioner code after ' + maxAttempts + ' attempts');
      }
      
      console.log('[generateUniquePractitionerCode] Generated unique code:', code);
      return code;
    }

    async function approveApplication(applicationId) {
      if (!confirm('Are you sure you want to approve this application?')) {
        return;
      }

      try {
        const db = window.firebaseDb || firebase.firestore();
        
        // Get the application document to retrieve email
        const appDoc = await db.collection('practitionerApplications').doc(applicationId).get();
        if (!appDoc.exists) {
          throw new Error('Application not found');
        }
        
        const appData = appDoc.data();
        const practitionerEmail = appData.email;
        
        if (!practitionerEmail) {
          throw new Error('Application email not found');
        }
        
        // Generate unique practitioner code
        console.log('[approveApplication] Generating unique practitioner code...');
        const practitionerCode = await generateUniquePractitionerCode();
        console.log('[approveApplication] Generated practitioner code:', practitionerCode);
        
        // Update application status
        await db.collection('practitionerApplications')
          .doc(applicationId)
          .update({
            status: 'approved',
            practitionerCode: practitionerCode, // Store code in application for reference
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        // Prepare user document data with all application fields and practitioner code
        const userDocumentData = {
          role: 'practitioner',
          practitionerStatus: 'approved',
          practitionerCode: practitionerCode,
          // Copy all application data to user profile
          firstName: appData.firstName || null,
          lastName: appData.lastName || null,
          name: `${appData.firstName || ''} ${appData.lastName || ''}`.trim() || null,
          email: practitionerEmail,
          phone: appData.phone || null,
          practiceName: appData.practiceName || null,
          practiceNumber: appData.practiceNumber || null,
          sarsNumber: appData.sarsNumber || null,
          yearsExperience: appData.yearsExperience || null,
          qualifications: appData.qualifications || null,
          specializations: appData.specializations || [],
          bio: appData.bio || null,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        // Remove null values to avoid overwriting with null
        Object.keys(userDocumentData).forEach(key => {
          if (userDocumentData[key] === null) {
            delete userDocumentData[key];
          }
        });
        
        // Try to find existing user document by email
        let userDocId = null;
        try {
          const usersSnapshot = await db.collection('users')
            .where('email', '==', practitionerEmail)
            .limit(1)
            .get();
          
          if (!usersSnapshot.empty) {
            // User document exists - update it
            const userDoc = usersSnapshot.docs[0];
            userDocId = userDoc.id;
            await userDoc.ref.set(userDocumentData, { merge: true });
            console.log('[approveApplication] ✅ Updated existing user document with practitioner code and application data:', userDocId);
            console.log('[approveApplication] Practitioner code assigned:', practitionerCode);
          } else {
            // User document doesn't exist - try to get UID from Firebase Auth
            // Note: We can't directly query Firebase Auth from client, but we can create a placeholder
            // The login flow will update this document with the correct UID when they log in
            
            // Try to find if there's a Firebase Auth user with this email
            // We'll create a temporary document keyed by email hash or wait for login
            // For now, we'll store the approval data in the application and let login.js handle document creation
            // But we can also try to create a document with email as a temporary identifier
            
            // Create a document with email-based ID (will be updated on login with actual UID)
            const emailBasedId = 'pending_' + practitionerEmail.replace(/[^a-zA-Z0-9]/g, '_');
            
            // Check if this temporary document exists
            const tempDocRef = db.collection('users').doc(emailBasedId);
            const tempDoc = await tempDocRef.get();
            
            if (!tempDoc.exists) {
              // Create temporary document with email-based ID
              await tempDocRef.set({
                ...userDocumentData,
                _isPending: true,
                _pendingEmail: practitionerEmail
              });
              console.log('[approveApplication] ✅ Created pending user document with practitioner code:', emailBasedId);
              console.log('[approveApplication] Practitioner code assigned:', practitionerCode);
              console.log('[approveApplication] Document will be migrated to actual UID on login');
            } else {
              // Update existing temporary document
              await tempDocRef.set(userDocumentData, { merge: true });
              console.log('[approveApplication] ✅ Updated pending user document with practitioner code:', emailBasedId);
            }
            
            userDocId = emailBasedId;
          }
        } catch (userDocError) {
          console.error('[approveApplication] Error creating/updating user document:', userDocError);
          // Continue anyway - the login flow will handle document creation with the practitioner code
          console.log('[approveApplication] Login flow will create user document with practitioner code on first login');
        }

        // Send password reset email
        try {
          await window.firebaseAuth.sendPasswordResetEmail(practitionerEmail);
          showAlert(`Application approved! Practitioner code: ${practitionerCode}. Password setup email sent to ${practitionerEmail}`, 'success');
        } catch (error) {
          console.error('Error sending password reset email:', error);
          showAlert(`Application approved! Practitioner code: ${practitionerCode}. Could not send password email: ${error.message || error.code}`, 'warning');
        }

        await loadApplications();
      } catch (error) {
        console.error('Error approving application:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        showAlert(error.message || 'Failed to approve application. Please try again.', 'error');
      }
    }

    async function rejectApplication(applicationId) {
      if (!confirm('Are you sure you want to reject this application?')) {
        return;
      }

      try {
        const db = window.firebaseDb || firebase.firestore();
        await db.collection('practitionerApplications')
          .doc(applicationId)
          .update({
          status: 'rejected',
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        showAlert('Application rejected.', 'success');
        await loadApplications();
      } catch (error) {
        console.error('Error rejecting application:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        showAlert(error.message || 'Failed to reject application. Please try again.', 'error');
      }
    }

    // Toggle Application Details (Mobile)
    function toggleApplicationDetails(appId) {
      const content = document.getElementById('details-' + appId);
      const icon = document.getElementById('icon-' + appId);
      const toggle = content ? content.previousElementSibling : null;
      const textSpan = toggle ? toggle.querySelector('span:last-child') : document.getElementById('text-' + appId);
      
      if (content && icon && textSpan) {
        content.classList.toggle('expanded');
        icon.classList.toggle('expanded');
        
        if (content.classList.contains('expanded')) {
          textSpan.textContent = 'Less Details';
        } else {
          textSpan.textContent = 'More Details';
        }
      }
    }

    // Setup filters and custom dropdown - must run after DOM is ready
    function setupFilters() {
      const filterStatus = document.getElementById('filterStatus');
      const filterSearch = document.getElementById('filterSearch');
      
      if (filterStatus) {
        filterStatus.addEventListener('change', renderApplications);
      }
      
      if (filterSearch) {
        filterSearch.addEventListener('input', renderApplications);
      }

      // Custom Mobile Dropdown
      const customTrigger = document.getElementById('customSelectTrigger');
      const customOptions = document.getElementById('customSelectOptions');
      const customText = document.getElementById('customSelectText');
      const nativeSelect = document.getElementById('filterStatus');

      if (customTrigger && customOptions && customText && nativeSelect) {
        const optionElements = customOptions.querySelectorAll('.custom-select-option');
        
        if (optionElements.length > 0) {
          
          // Sync custom dropdown with native select
          function updateCustomSelect() {
            const selectedValue = nativeSelect.value;
            const selectedText = nativeSelect.options[nativeSelect.selectedIndex].text;
            customText.textContent = selectedText;
            
            optionElements.forEach(opt => {
              opt.classList.remove('selected');
              if (opt.dataset.value === selectedValue) {
                opt.classList.add('selected');
              }
            });
          }

          // Toggle dropdown
          customTrigger.addEventListener('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            const isActive = customTrigger.classList.contains('active');
            
            customTrigger.classList.toggle('active');
            customOptions.classList.toggle('active');
            
          });

          // Handle option selection
          optionElements.forEach(option => {
            option.addEventListener('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              const value = this.dataset.value;
              
              nativeSelect.value = value;
              customText.textContent = this.textContent;
              
              optionElements.forEach(opt => opt.classList.remove('selected'));
              this.classList.add('selected');
              
              customTrigger.classList.remove('active');
              customOptions.classList.remove('active');
              
              // Trigger change event on native select
              const changeEvent = new Event('change', { bubbles: true });
              nativeSelect.dispatchEvent(changeEvent);
            });
          });

          // Close dropdown when clicking outside
          document.addEventListener('click', function(e) {
            if (customTrigger.classList.contains('active')) {
              if (!customTrigger.contains(e.target) && !customOptions.contains(e.target)) {
                customTrigger.classList.remove('active');
                customOptions.classList.remove('active');
              }
            }
          });

          // Sync when native select changes (e.g., from code)
          nativeSelect.addEventListener('change', updateCustomSelect);
          
          // Initial sync
          updateCustomSelect();
        } else {
          console.warn('[Custom Dropdown] No option elements found');
        }
      } else {
        console.warn('[Custom Dropdown] Required elements not found:', {
          customTrigger: !!customTrigger,
          customOptions: !!customOptions,
          customText: !!customText,
          nativeSelect: !!nativeSelect
        });
      }
    }

    // Mobile Navigation Functions
    // Style 6: Compact Dropdown Menu Toggle
    // Style 6 Mobile Navigation Functions
    function toggleMenuStyle6() {
        const menuToggle = document.getElementById('menuToggle');
        const mainNav = document.getElementById('mainNav');
        
        if (menuToggle && mainNav) {
            menuToggle.classList.toggle('active');
            mainNav.classList.toggle('active');
        }
    }
    
    // Close Style 6 menu when clicking outside
    document.addEventListener('click', function(event) {
        const menuToggle = document.getElementById('menuToggle');
        const mainNav = document.getElementById('mainNav');
        
        if (mainNav && mainNav.classList.contains('active')) {
            // Check if click is outside the menu and toggle button
            if (!mainNav.contains(event.target) && !menuToggle.contains(event.target)) {
                menuToggle.classList.remove('active');
                mainNav.classList.remove('active');
            }
        }
    });
    
    // Close Style 6 menu when pressing Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            const menuToggle = document.getElementById('menuToggle');
            const mainNav = document.getElementById('mainNav');
            if (menuToggle && mainNav) {
                menuToggle.classList.remove('active');
                mainNav.classList.remove('active');
            }
        }
    });
    
    function toggleMenu(prefix) {
        const nav = document.getElementById(`nav-${prefix}`);
        const toggle = document.querySelector(`.menu-toggle-style6`);
        
        if (nav && toggle) {
            nav.classList.toggle('active');
            toggle.classList.toggle('active');
        }
    }
    
    // Close menus when clicking outside (for dropdowns)
    document.addEventListener('click', function(event) {
        const nav = document.getElementById('nav-admin');
        const toggle = document.querySelector('.menu-toggle-style6');
        const header = toggle?.closest('header');
        
        if (nav && nav.classList.contains('active')) {
            if (header && !header.contains(event.target)) {
                nav.classList.remove('active');
                if (toggle) toggle.classList.remove('active');
            }
        }
    });
    

    /**
     * Find matching practitioner for client based on requirements
     * @param {string[]} clientNeeds - Array of client specializations/needs
     * @param {string} excludedPractitionerId - Practitioner ID to exclude from matching
     * @returns {Promise<string|null>} Matching practitioner ID or null
     */
    async function findMatchingPractitioner(clientNeeds, excludedPractitionerId) {
      const db = window.firebaseDb || firebase.firestore();
      if (!db) return null;
      
      try {
        // Get all active practitioners (not suspended, not deleted, not fraud)
        const practitionersSnapshot = await db.collection('users')
          .where('role', '==', 'practitioner')
          .get();
        
        if (practitionersSnapshot.empty) {
          return null;
        }
        
        let practitioners = practitionersSnapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(p => {
            // Exclude the practitioner being deleted/suspended
            if (p.id === excludedPractitionerId) return false;
            // Exclude suspended practitioners
            if (p.practitionerStatus === 'suspended') return false;
            // Exclude fraud-tagged practitioners
            if (p.fraudTagged === true) return false;
            // Exclude deleted practitioners
            if (p.practitionerStatus === 'deleted') return false;
            return true;
          });
        
        if (practitioners.length === 0) {
          return null;
        }
        
        // If client has needs/specializations, try to match
        if (clientNeeds && Array.isArray(clientNeeds) && clientNeeds.length > 0) {
          const matching = practitioners.filter(p => {
            const practitionerSpecs = p.specializations || [];
            // Check if practitioner has at least one matching specialization
            return clientNeeds.some(need => practitionerSpecs.includes(need));
          });
          
          // If we found matches, use those; otherwise use all practitioners
          if (matching.length > 0) {
            practitioners = matching;
          }
        }
        
        // Sort by rotationIndex for load balancing
        practitioners.sort((a, b) => {
          const aIndex = a.rotationIndex || 0;
          const bIndex = b.rotationIndex || 0;
          if (aIndex !== bIndex) return aIndex - bIndex;
          // If rotationIndex is same, use createdAt
          const aCreated = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt || 0);
          const bCreated = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt || 0);
          return aCreated - bCreated;
        });
        
        // Return the first matching practitioner
        return practitioners.length > 0 ? practitioners[0].id : null;
      } catch (error) {
        console.error('Error finding matching practitioner:', error);
        return null;
      }
    }
    
    /**
     * Reassign clients to new practitioners when their current practitioner is removed
     * @param {string} practitionerId - ID of practitioner being removed
     * @param {string} reason - Reason for reassignment (e.g., 'practitioner_deleted', 'fraud_appeal_deadline_expired')
     * @returns {Promise<Object>} Result object with success, reassigned, failed counts
     */
    async function reassignClientsToNewPractitioners(practitionerId, reason) {
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        console.error('Database not available for reassignment');
        return { success: false, reassigned: 0, failed: 0 };
      }
      
      try {
        // Find all clients connected to this practitioner
        // Method 1: Check users collection
        const usersSnapshot = await db.collection('users')
          .where('connectedPractitioner', '==', practitionerId)
          .get();
        
        // Method 2: Check connections collection
        const connectionsSnapshot = await db.collection('connections')
          .where('practitionerId', '==', practitionerId)
          .where('status', '==', 'active')
          .get();
        
        const clientIds = new Set();
        
        // Collect client IDs from users collection
        usersSnapshot.forEach(doc => {
          clientIds.add(doc.id);
        });
        
        // Collect client IDs from connections collection
        connectionsSnapshot.forEach(doc => {
          const data = doc.data();
          if (data.userId) {
            clientIds.add(data.userId);
          }
        });
        
        if (clientIds.size === 0) {
          console.log('No clients found to reassign');
          return { success: true, reassigned: 0, failed: 0 };
        }
        
        console.log(`Found ${clientIds.size} clients to reassign`);
        
        let reassigned = 0;
        let failed = 0;
        const reassignmentResults = [];
        
        // Reassign each client
        for (const clientId of clientIds) {
          try {
            // Get client data to find their needs/specializations
            const clientDoc = await db.collection('users').doc(clientId).get();
            const clientData = clientDoc.exists ? clientDoc.data() : {};
            
            // Try to get client needs from clientRequests
            let clientNeeds = [];
            const clientRequestsSnapshot = await db.collection('clientRequests')
              .where('clientUid', '==', clientId)
              .orderBy('createdAt', 'desc')
              .limit(1)
              .get();
            
            if (!clientRequestsSnapshot.empty) {
              const requestData = clientRequestsSnapshot.docs[0].data();
              clientNeeds = requestData.needs || [];
            }
            
            // Find matching practitioner
            const newPractitionerId = await findMatchingPractitioner(clientNeeds, practitionerId);
            
            if (newPractitionerId) {
              // Get FieldValue reference
              const FieldValue = (window.firebaseDb && window.firebaseDb.app) 
                ? window.firebaseDb.app.firestore().FieldValue 
                : (typeof firebase !== 'undefined' ? firebase.firestore.FieldValue : null);
              
              // Update user document
              await db.collection('users').doc(clientId).update({
                connectedPractitioner: newPractitionerId,
                previousPractitioner: practitionerId,
                reassignedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                reassignedReason: reason,
                updatedAt: FieldValue ? FieldValue.serverTimestamp() : new Date()
              });
              
              // Update or create connection document
              const existingConnection = await db.collection('connections')
                .where('userId', '==', clientId)
                .where('practitionerId', '==', practitionerId)
                .limit(1)
                .get();
              
              if (!existingConnection.empty) {
                // Update existing connection
                await db.collection('connections').doc(existingConnection.docs[0].id).update({
                  status: 'reassigned',
                  previousPractitionerId: practitionerId,
                  reassignedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                  reassignedReason: reason
                });
              }
              
              // Create new connection
              await db.collection('connections').add({
                userId: clientId,
                practitionerId: newPractitionerId,
                previousPractitionerId: practitionerId,
                connectedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                reassignedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                reassignedReason: reason,
                status: 'active'
              });
              
              // Increment rotation index for load balancing
              const practitionerRef = db.collection('users').doc(newPractitionerId);
              const practitionerDoc = await practitionerRef.get();
              const currentIndex = practitionerDoc.data()?.rotationIndex || 0;
              await practitionerRef.update({
                rotationIndex: currentIndex + 1
              });
              
              reassigned++;
              reassignmentResults.push({
                clientId,
                newPractitionerId,
                success: true
              });
              
              console.log(`✅ Reassigned client ${clientId} to practitioner ${newPractitionerId}`);
            } else {
              // Get FieldValue reference
              const FieldValue = (window.firebaseDb && window.firebaseDb.app) 
                ? window.firebaseDb.app.firestore().FieldValue 
                : (typeof firebase !== 'undefined' ? firebase.firestore.FieldValue : null);
              
              // No matching practitioner found - mark as unassigned
              await db.collection('users').doc(clientId).update({
                connectedPractitioner: null,
                previousPractitioner: practitionerId,
                reassignedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                reassignedReason: reason,
                needsReassignment: true,
                updatedAt: FieldValue ? FieldValue.serverTimestamp() : new Date()
              });
              
              // Update connection status
              const existingConnection = await db.collection('connections')
                .where('userId', '==', clientId)
                .where('practitionerId', '==', practitionerId)
                .limit(1)
                .get();
              
              if (!existingConnection.empty) {
                await db.collection('connections').doc(existingConnection.docs[0].id).update({
                  status: 'unassigned',
                  previousPractitionerId: practitionerId,
                  reassignedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
                  reassignedReason: reason
                });
              }
              
              failed++;
              reassignmentResults.push({
                clientId,
                newPractitionerId: null,
                success: false,
                reason: 'No matching practitioner found'
              });
              
              console.warn(`⚠️ Could not find matching practitioner for client ${clientId}`);
            }
          } catch (error) {
            console.error(`Error reassigning client ${clientId}:`, error);
            failed++;
            reassignmentResults.push({
              clientId,
              success: false,
              error: error.message
            });
          }
        }
        
        return {
          success: true,
          reassigned,
          failed,
          total: clientIds.size,
          results: reassignmentResults
        };
      } catch (error) {
        console.error('Error in reassignClientsToNewPractitioners:', error);
        return { success: false, error: error.message, reassigned: 0, failed: 0 };
      }
    }
    
    // Reassign clients from fraud-tagged practitioners after grace period expires
    // This function shows a selection interface to choose which practitioners to process
    window.reassignClientsFromFraudTaggedPractitioners = async function() {
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        showAlert('Database not available', 'error');
        return;
      }
      
      try {
        // Find all fraud-tagged practitioners whose appeal deadline has passed
        const now = new Date();
        const practitionersSnapshot = await db.collection('users')
          .where('role', '==', 'practitioner')
          .where('fraudTagged', '==', true)
          .get();
        
        const expiredFraudPractitioners = [];
        
        practitionersSnapshot.forEach(doc => {
          const data = doc.data();
          const appealDeadline = data.fraudAppealDeadline;
          
          if (appealDeadline) {
            const deadlineDate = new Date(appealDeadline);
            if (deadlineDate < now) {
              expiredFraudPractitioners.push({
                id: doc.id,
                email: data.email,
                firstName: data.firstName || '',
                lastName: data.lastName || '',
                practiceName: data.practiceName || '',
                deadline: appealDeadline,
                deadlineFormatted: deadlineDate.toLocaleDateString()
              });
            }
          }
        });
        
        if (expiredFraudPractitioners.length === 0) {
          showAlert('No fraud-tagged practitioners have passed their appeal deadline.', 'info');
          return;
        }
        
        // Create modal for selection
        const modal = document.createElement('div');
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
        modal.innerHTML = `
          <div style="background: white; border-radius: 8px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h2 style="margin-top: 0; margin-bottom: 1rem;">Select Practitioners to Reassign Clients</h2>
            <p style="color: #666; margin-bottom: 1.5rem;">Select which fraud-tagged practitioners' clients should be reassigned:</p>
            <div id="practitionerSelectionList" style="margin-bottom: 1.5rem;">
              ${expiredFraudPractitioners.map((p, index) => `
                <label style="display: flex; align-items: center; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 6px; margin-bottom: 0.5rem; cursor: pointer; transition: background 0.2s;">
                  <input type="checkbox" value="${p.id}" data-practitioner-id="${p.id}" style="margin-right: 0.75rem; width: 18px; height: 18px; cursor: pointer;">
                  <div style="flex: 1;">
                    <div style="font-weight: 600; color: #111827;">${p.practiceName || `${p.firstName} ${p.lastName}`}</div>
                    <div style="font-size: 0.875rem; color: #6b7280;">${p.email}</div>
                    <div style="font-size: 0.75rem; color: #9ca3af; margin-top: 0.25rem;">Deadline passed: ${p.deadlineFormatted}</div>
                  </div>
                </label>
              `).join('')}
            </div>
            <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
              <button id="cancelReassignBtn" style="padding: 0.5rem 1.5rem; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
              <button id="confirmReassignBtn" style="padding: 0.5rem 1.5rem; background: #059669; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">Reassign Selected</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Handle cancel
        modal.querySelector('#cancelReassignBtn').onclick = () => {
          document.body.removeChild(modal);
        };
        
        // Handle confirm
        modal.querySelector('#confirmReassignBtn').onclick = async () => {
          const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
          const selectedIds = Array.from(checkboxes).map(cb => cb.value);
          
          if (selectedIds.length === 0) {
            showAlert('Please select at least one practitioner.', 'warning');
            return;
          }
          
          document.body.removeChild(modal);
          
          const selectedPractitioners = expiredFraudPractitioners.filter(p => selectedIds.includes(p.id));
          
          let totalReassigned = 0;
          let totalFailed = 0;
          const results = [];
          
          for (const practitioner of selectedPractitioners) {
            showAlert(`Reassigning clients from ${practitioner.email}...`, 'info');
            const result = await reassignClientsToNewPractitioners(practitioner.id, 'fraud_appeal_deadline_expired');
            
            if (result.success) {
              totalReassigned += result.reassigned || 0;
              totalFailed += result.failed || 0;
              results.push({
                practitionerId: practitioner.id,
                email: practitioner.email,
                ...result
              });
            }
          }
          
          // Show summary
          if (totalReassigned > 0 || totalFailed > 0) {
            showAlert(`Reassignment complete. ${totalReassigned} client(s) reassigned, ${totalFailed} client(s) need manual assignment.`, 'success');
          } else {
            showAlert('Reassignment complete. No clients found to reassign.', 'info');
          }
          
          // Reload applications
          setTimeout(() => {
            if (typeof loadApplications === 'function') {
              loadApplications();
            }
          }, 2000);
          
          return {
            success: true,
            totalReassigned,
            totalFailed,
            results
          };
        };
        
      } catch (error) {
        console.error('Error reassigning clients from fraud-tagged practitioners:', error);
        showAlert('Failed to reassign clients: ' + (error.message || error.code), 'error');
        return { success: false, error: error.message };
      }
    };
    
    /**
     * Suspend a practitioner (clients remain connected for reactivation)
     * @param {string} email - Practitioner email address
     */
    window.suspendPractitionerByEmail = async function(email) {
      if (!email) {
        showAlert('Error: No email provided', 'error');
        return;
      }
      
      if (!confirm('Are you sure you want to suspend this practitioner?')) {
        return;
      }
      
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        showAlert('Database not available', 'error');
        return;
      }
      
      try {
        // Find user by email - try exact, then variations
        let snapshot = await db.collection('users')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (snapshot.empty && email.trim() !== email) {
          snapshot = await db.collection('users')
            .where('email', '==', email.trim())
            .limit(1)
            .get();
        }
        
        if (snapshot.empty) {
          snapshot = await db.collection('users')
            .where('email', '==', email.toLowerCase().trim())
            .limit(1)
            .get();
        }
        
        if (snapshot.empty) {
          showAlert('User not found for this email.', 'error');
          return;
        }
        
        const userId = snapshot.docs[0].id;
        
        // Update status
        await db.collection('users').doc(userId).update({
          practitionerStatus: 'suspended'
        });
        
        // Note: We do NOT reassign clients on suspend because practitioners can be reactivated
        // Clients remain connected to allow seamless reactivation
        
        showAlert('Practitioner suspended successfully. Clients remain connected and will be available upon reactivation.', 'success');
        
        // Reload after delay
        setTimeout(() => {
          if (typeof loadApplications === 'function') {
            loadApplications();
          }
        }, 1500);
        
      } catch (error) {
        showAlert('Failed to suspend practitioner: ' + (error.message || error.code), 'error');
      }
    };

    /**
     * Reactivate a suspended practitioner
     * @param {string} email - Practitioner email address
     */
    window.reactivatePractitionerByEmail = async function(email) {
      console.log('[reactivatePractitionerByEmail] Called with email:', email);
      if (!email) {
        console.error('[reactivatePractitionerByEmail] No email provided');
        showAlert('Error: No email provided', 'error');
        return;
      }
      if (!confirm('Are you sure you want to reactivate this practitioner?')) {
        return;
      }
      
      const db = window.firebaseDb || firebase.firestore();
      try {
        // Try to find user by email - try both exact and normalized versions
        let userId = null;
        let userDoc = null;
        
        // Try exact email first
        let usersSnapshot = await db.collection('users')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (usersSnapshot.empty) {
          // Try normalized (lowercase) email
          const normalizedEmail = email.toLowerCase().trim();
          console.log('[reactivatePractitionerByEmail] Trying normalized email:', normalizedEmail);
          usersSnapshot = await db.collection('users')
            .where('email', '==', normalizedEmail)
            .limit(1)
            .get();
        }
        
        if (usersSnapshot.empty) {
          // Try with trimmed email
          const trimmedEmail = email.trim();
          if (trimmedEmail !== email) {
            console.log('[reactivatePractitionerByEmail] Trying trimmed email:', trimmedEmail);
            usersSnapshot = await db.collection('users')
              .where('email', '==', trimmedEmail)
              .limit(1)
              .get();
          }
        }
        
        if (!usersSnapshot.empty) {
          userDoc = usersSnapshot.docs[0];
          userId = userDoc.id;
          const userData = userDoc.data();
          console.log('[reactivatePractitionerByEmail] Found user by email, userId:', userId);
          console.log('[reactivatePractitionerByEmail] User document data:', userData);
          console.log('[reactivatePractitionerByEmail] Current practitionerStatus:', userData.practitionerStatus);
        } else {
          console.error('[reactivatePractitionerByEmail] User not found with email:', email);
          showAlert('User document not found for this email. The practitioner may need to log in first.', 'error');
          return;
        }
        
        if (!userId) {
          showAlert('Could not find user document for this email.', 'error');
          return;
        }
        
        // Use update to ensure we're updating the existing document
        console.log('[reactivatePractitionerByEmail] Updating user document:', userId);
        await db.collection('users').doc(userId).update({
          practitionerStatus: 'approved'
        });
        
        console.log('[reactivatePractitionerByEmail] Update call completed');
        
        console.log('[reactivatePractitionerByEmail] Update completed, verifying...');
        
        // Verify the update by reading the document back
        await new Promise(resolve => setTimeout(resolve, 800)); // Increased delay for Firestore propagation
        const verifyDoc = await db.collection('users').doc(userId).get();
        
        if (!verifyDoc.exists) {
          console.error('[reactivatePractitionerByEmail] Document does not exist after update!');
          showAlert('Error: Document was not created/updated. Please try again.', 'error');
          return;
        }
        
        const verifyData = verifyDoc.data();
        console.log('[reactivatePractitionerByEmail] Verified data:', verifyData);
        console.log('[reactivatePractitionerByEmail] practitionerStatus in doc:', verifyData.practitionerStatus);
        
        if (verifyData.practitionerStatus !== 'approved') {
          console.error('[reactivatePractitionerByEmail] WARNING: Status was not updated correctly!');
          console.error('[reactivatePractitionerByEmail] Expected: approved, Got:', verifyData.practitionerStatus);
          showAlert('Update may not have been saved correctly. Please refresh the page.', 'warning');
          return;
        }
        
        console.log('[reactivatePractitionerByEmail] ✅ Successfully reactivated practitioner');
        showAlert('Practitioner reactivated successfully.', 'success');
        
        // Force reload applications to update the button - add a delay to ensure Firestore has propagated
        await new Promise(resolve => setTimeout(resolve, 1000));
        if (typeof loadApplications === 'function') {
          console.log('[reactivatePractitionerByEmail] Reloading applications...');
          await loadApplications();
          console.log('[reactivatePractitionerByEmail] Applications reloaded');
        } else {
          console.error('[reactivatePractitionerByEmail] loadApplications function not found!');
        }
      } catch (error) {
        console.error('[reactivatePractitionerByEmail] Error reactivating practitioner by email:', error);
        console.error('[reactivatePractitionerByEmail] Error code:', error.code);
        console.error('[reactivatePractitionerByEmail] Error message:', error.message);
        console.error('[reactivatePractitionerByEmail] Error stack:', error.stack);
        showAlert(error.message || 'Failed to reactivate practitioner. Please check console for details.', 'error');
      }
    };
    
    /**
     * Permanently delete a practitioner and reassign their clients
     * @param {string} email - Practitioner email address
     */
    window.deletePractitioner = async function(email) {
      if (!email) {
        showAlert('Error: No email provided', 'error');
        return;
      }
      
      if (!confirm('⚠️ WARNING: This will permanently delete this practitioner and all associated data. This action cannot be undone.\n\nAre you absolutely sure you want to delete this practitioner?')) {
        return;
      }
      
      // Double confirmation for safety
      if (!confirm('This is your final confirmation. Click OK to permanently delete this practitioner.')) {
        return;
      }
      
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        showAlert('Database not available', 'error');
        return;
      }
      
      try {
        // Find user by email
        let snapshot = await db.collection('users')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (snapshot.empty) {
          snapshot = await db.collection('users')
            .where('email', '==', email.toLowerCase().trim())
            .limit(1)
            .get();
        }
        
        if (snapshot.empty) {
          showAlert('User not found for this email.', 'error');
          return;
        }
        
        const userId = snapshot.docs[0].id;
        const userDoc = snapshot.docs[0];
        
        // Get practitioner code if exists
        const userData = userDoc.data();
        const practitionerCode = userData.practitionerCode;
        
        // Reassign clients BEFORE deleting practitioner
        showAlert('Reassigning clients to new practitioners...', 'info');
        const reassignmentResult = await reassignClientsToNewPractitioners(userId, 'practitioner_deleted');
        
        // Delete user document
        await db.collection('users').doc(userId).delete();
        
        // Also update the application status to 'deleted' if application exists
        const appSnapshot = await db.collection('practitionerApplications')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (!appSnapshot.empty) {
          const FieldValue = (window.firebaseDb && window.firebaseDb.app) 
            ? window.firebaseDb.app.firestore().FieldValue 
            : (typeof firebase !== 'undefined' ? firebase.firestore.FieldValue : null);
          
          if (FieldValue) {
            await db.collection('practitionerApplications')
              .doc(appSnapshot.docs[0].id)
              .update({
                status: 'deleted',
                deletedAt: FieldValue.serverTimestamp(),
                deletedBy: 'admin'
              });
          } else {
            await db.collection('practitionerApplications')
              .doc(appSnapshot.docs[0].id)
              .update({
                status: 'deleted',
                deletedBy: 'admin'
              });
          }
        }
        
        // Show reassignment results
        if (reassignmentResult.success) {
          if (reassignmentResult.reassigned > 0) {
            showAlert(`Practitioner deleted successfully. ${reassignmentResult.reassigned} client(s) reassigned to new practitioners.`, 'success');
          } else if (reassignmentResult.failed > 0) {
            showAlert(`Practitioner deleted. ${reassignmentResult.failed} client(s) could not be automatically reassigned and need manual assignment.`, 'warning');
          } else {
            showAlert('Practitioner deleted successfully. No clients to reassign.', 'success');
          }
        } else {
          showAlert('Practitioner deleted, but client reassignment encountered issues. Please check manually.', 'warning');
        }
        
        // Reload after delay
        setTimeout(() => {
          if (typeof loadApplications === 'function') {
            loadApplications();
          }
        }, 2000);
        
      } catch (error) {
        console.error('Error deleting practitioner:', error);
        showAlert('Failed to delete practitioner: ' + (error.message || error.code), 'error');
      }
    };
    
    /**
     * Tag a practitioner as fraud (30-day grace period before client reassignment)
     * @param {string} email - Practitioner email address
     */
    window.tagPractitionerAsFraud = async function(email) {
      if (!email) {
        showAlert('Error: No email provided', 'error');
        return;
      }
      
      if (!confirm('Are you sure you want to tag this practitioner as fraud?\n\nThis will mark their account and application as fraudulent.')) {
        return;
      }
      
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        showAlert('Database not available', 'error');
        return;
      }
      
      try {
        // Find user by email
        let snapshot = await db.collection('users')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (snapshot.empty) {
          snapshot = await db.collection('users')
            .where('email', '==', email.toLowerCase().trim())
            .limit(1)
            .get();
        }
        
        if (snapshot.empty) {
          showAlert('User not found for this email.', 'error');
          return;
        }
        
        const userId = snapshot.docs[0].id;
        
        // Get FieldValue for timestamps
        const FieldValue = (window.firebaseDb && window.firebaseDb.app) 
          ? window.firebaseDb.app.firestore().FieldValue 
          : (typeof firebase !== 'undefined' ? firebase.firestore.FieldValue : null);
        
        // Calculate appeal deadline (30 days from now)
        const appealDeadlineDate = new Date();
        appealDeadlineDate.setDate(appealDeadlineDate.getDate() + 30);
        
        // Update user document with fraud flag and appeal deadline
        // Note: Clients are NOT immediately reassigned - 30-day grace period for appeal
        const userUpdate = {
          practitionerStatus: 'fraud',
          fraudTagged: true,
          fraudAppealDeadline: appealDeadlineDate.toISOString() // Store as ISO string for easy comparison
        };
        if (FieldValue) {
          userUpdate.fraudTaggedAt = FieldValue.serverTimestamp();
        }
        await db.collection('users').doc(userId).update(userUpdate);
        
        // Also update the application status to 'fraud'
        const appSnapshot = await db.collection('practitionerApplications')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (!appSnapshot.empty) {
          const appUpdate = {
            status: 'fraud',
            fraudTagged: true
          };
          if (FieldValue) {
            appUpdate.fraudTaggedAt = FieldValue.serverTimestamp();
          }
          await db.collection('practitionerApplications')
            .doc(appSnapshot.docs[0].id)
            .update(appUpdate);
        }
        
        // Note: Clients are NOT immediately reassigned when fraud is tagged
        // A 30-day grace period is given for appeal before clients are reassigned
        // Use reassignClientsFromFraudTaggedPractitioners() after the grace period expires
        
        showAlert('Practitioner tagged as fraud successfully. Clients will remain connected for 30 days to allow for appeal. After the grace period, clients can be reassigned.', 'success');
        
        // Reload after delay
        setTimeout(() => {
          if (typeof loadApplications === 'function') {
            loadApplications();
          }
        }, 1500);
        
      } catch (error) {
        console.error('Error tagging practitioner as fraud:', error);
        showAlert('Failed to tag practitioner as fraud: ' + (error.message || error.code), 'error');
      }
    };
    
    /**
     * Clear fraud tag for practitioners who won their appeal
     * Restores practitioner to active status
     * @param {string} email - Practitioner email address
     */
    window.clearFraudTag = async function(email) {
      if (!email) {
        showAlert('Error: No email provided', 'error');
        return;
      }
      
      if (!confirm('Are you sure you want to clear the fraud tag for this practitioner?\n\nThis will restore them to active status and they will be able to continue serving their clients.')) {
        return;
      }
      
      const db = window.firebaseDb || firebase.firestore();
      if (!db) {
        showAlert('Database not available', 'error');
        return;
      }
      
      try {
        // Find user by email
        let snapshot = await db.collection('users')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (snapshot.empty) {
          snapshot = await db.collection('users')
            .where('email', '==', email.toLowerCase().trim())
            .limit(1)
            .get();
        }
        
        if (snapshot.empty) {
          showAlert('User not found for this email.', 'error');
          return;
        }
        
        const userId = snapshot.docs[0].id;
        
        // Get FieldValue for timestamps
        const FieldValue = (window.firebaseDb && window.firebaseDb.app) 
          ? window.firebaseDb.app.firestore().FieldValue 
          : (typeof firebase !== 'undefined' ? firebase.firestore.FieldValue : null);
        
        // Clear fraud tag and restore to approved status
        const userUpdate = {
          practitionerStatus: 'approved',
          fraudTagged: false,
          fraudClearedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
          fraudAppealResolved: true
        };
        
        // Remove appeal deadline if it exists
        await db.collection('users').doc(userId).update(userUpdate);
        
        // Also update the application status if it exists
        const appSnapshot = await db.collection('practitionerApplications')
          .where('email', '==', email)
          .limit(1)
          .get();
        
        if (!appSnapshot.empty) {
          const appUpdate = {
            status: 'approved',
            fraudTagged: false,
            fraudClearedAt: FieldValue ? FieldValue.serverTimestamp() : new Date(),
            fraudAppealResolved: true
          };
          await db.collection('practitionerApplications')
            .doc(appSnapshot.docs[0].id)
            .update(appUpdate);
        }
        
        showAlert('Fraud tag cleared successfully. Practitioner restored to active status.', 'success');
        
        // Reload after delay
        setTimeout(() => {
          if (typeof loadApplications === 'function') {
            loadApplications();
          }
        }, 1500);
        
      } catch (error) {
        console.error('Error clearing fraud tag:', error);
        showAlert('Failed to clear fraud tag: ' + (error.message || error.code), 'error');
      }
    };
    
    // Create local references for event delegation
    const reactivatePractitionerByEmail = window.reactivatePractitionerByEmail;

    // Initialize function
    async function initializeAdminDashboardPage() {
      try {
      // Wait for auth to be ready (dashboard-auth.js will handle redirects)
      const initSuccess = await initializeAdminDashboard();
        
      if (initSuccess) {
        await loadApplications();
        } else {
          console.error('[admin-dashboard] Initialization failed!');
        }

      } catch (error) {
        console.error('[admin-dashboard] Error during initialization:', error);
        console.error('[admin-dashboard] Error stack:', error.stack);
      }
    }
    
    // Initialize - dashboard-auth.js handles authentication, we just need to set email and load data
    
    function initializePage() {
      initializeAdminDashboardPage();
      setupFilters(); // Setup filters and custom dropdown after DOM is ready
      // Event delegation will be set up after applications are rendered
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializePage);
    } else {
      initializePage();
    }
  </script>
</body>
</html>

